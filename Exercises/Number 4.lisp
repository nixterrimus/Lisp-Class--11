; Nicholas Rowe

; Bingo!  Allows the game to be optionally sized using the :size key.  If no size is given the game defaults to size 5
;   Also allows the max random to be selected using the max-random key.  The formatting gets a bit wonky if sizes greater
;   than 99 are used.

(defstruct Bingo card mark)

; Makes a bingo card uses optional size and max-random to generate the card
;   The card is generated by using a double for loop and collecting the result to use as the initial values
(defun make-my-bingo (&key (size 5) (max-random 50))
    (make-Bingo 
        :card (make-array (list size size) :initial-contents (loop for j from 1 to size collect (loop for i from 1 to size collect (+ 1 (random max-random)))))
        :mark (make-array (list size size) :initial-element 0))
)

; Marks a number as played on a bingo card
;   Double for loop design
(defun mark (bingo number) 
    (loop for j from 0 to (- (first (array-dimensions (bingo-card bingo))) 1) do
        (loop for k from 0 to (- (second (array-dimensions (bingo-card bingo))) 1) do
            (if (= (aref (bingo-card bingo) j k) number) (setf (aref (bingo-mark bingo) j k) 1))))
    bingo
)

; Checks if bingo has been scored for a given card
;   Works by taking a row (or column or diagonal) and reducing the value of the complete row using an AND function
;   The set of rows are then Or'd to find out if any of the rows containing a true value.  This total set if Or'd with
;   the other combinations (column and diagonal).  This solution is neat because it's lisp-y but the downside is that 
;   this algorithm doesn't tell where the winning value is located.
;
;   This implementation of the game assumes that if you are using a non size 5 gameboard then the board must have a 
;   complete row or complete column or complete diagonal to win.  That is 6 spaces in a row for size 6 and 7 for 7 and so on.
(defun isBingo (bingo)
    (or
        ; Check Rows
        ;   Create a list of each row- evaluate the value of and'ing the whole row
        ;   Or the list of row values
        (reduce (lambda (x y) (or x y)) (loop for j from 0 to (- (first (array-dimensions (bingo-card bingo))) 1) collect
            (reduce (lambda (x y) (and x y)) (loop for k from 0 to (- (second (array-dimensions (bingo-card bingo))) 1) collect (not (zerop (aref (bingo-mark bingo) j k)))))
        ))

        ; Check columns if the same manner
        (reduce (lambda (x y) (or x y)) (loop for j from 0 to (- (first (array-dimensions (bingo-card bingo))) 1) collect
            (reduce (lambda (x y) (and x y)) (loop for k from 0 to (- (second (array-dimensions (bingo-card bingo))) 1) collect (not (zerop (aref (bingo-mark bingo) k j)))))
        ))

        ; Check diagonal
        (reduce (lambda (x y) (and x y)) (loop for k from 0 to (- (first (array-dimensions (bingo-card bingo))) 1) collect (not (zerop (aref (bingo-mark bingo) k k)))))
    )
)

; Displays a given bingo card
;   Double for loop design with some formatting tricks to make sure each bingo card takes up at least 2 space
(defun display (bingo)
    (format t "~%~a~%" (coerce (loop for j from 1 to (* (second (array-dimensions (bingo-card bingo))) 6) collect #\-) 'string))
    (loop for j from 0 to (- (first (array-dimensions (bingo-card bingo))) 1) do
        (format t "|")
        (loop for k from 0 to (- (second (array-dimensions (bingo-card bingo))) 1) do
            (format t " ~2,'0d~a |" (aref (bingo-card bingo) j k) (if (zerop (aref (bingo-mark bingo) j k)) " " "*")))
        (format t "~%~a~%" (coerce (loop for j from 1 to (* (second (array-dimensions (bingo-card bingo))) 6) collect #\-) 'string)))
)

; Plays the bingo game!
;   Nothin' tricky.
(defun bingo-game(&key (size 5))
    (let ((card1 (make-my-bingo :size size)) (card2 (make-my-bingo :size size)) (input nil))
        (format t "Let's get ready to bingo!~%")
        (loop while (not (or (isBingo card1) (isBingo card2))) do
            (format t "Call a number!: ")
            
            (if (numberp (setf input (read)))
                (progn
                    (display (mark card1 input))
                    (display (mark card2 input))) 
                    
                (format t "Numbers only, please~%"))
        )
        
        (if (and (isBingo card1) (isBingo card2)) (format t "It's a tie!"))
        (if (and (isBingo card1) (not (isBingo card2))) (format t "Player 1 is the winner!") (format t "Player 2 is the winner"))
        
        (display (mark card1))
        (display (mark card2))) 
    )
)

;  ----
;   Copyright (C) 2011 by Nick Rowe

;  Permission is hereby granted, free of charge, to any person obtaining a copy
;  of this software and associated documentation files (the "Software"), to deal
;  in the Software without restriction, including without limitation the rights
;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;  copies of the Software, and to permit persons to whom the Software is
;  furnished to do so, subject to the following conditions:

;  The above copyright notice and this permission notice shall be included in
;  all copies or substantial portions of the Software.

;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
;  THE SOFTWARE.
